# 実行時間プロファイリングレポート（viztracer）

## エグゼクティブサマリー

- ステータス: main.py の代表的な実行で完了
- 主な所見: AStarPathfinder.find_path が実行時間の大半を占有。heap 操作が頻繁。トレースバッファが溢れ、初期のデータが欠落
- 優先アクション: find_path のコアループと heap 操作を Rust 化。バッファ拡大またはフィルタ付きで再計測

## プロファイリング設定

- ツール: uv の開発依存として viztracer
- 対象: main.py
- トレース出力: specs/001-plan/artifacts/viztracer-main.json

## 実行メタデータ

- 日付: 2026-02-09
- コマンド: uv run python -m viztracer -o specs/001-plan/artifacts/viztracer-main.json main.py
- 入力データ / パラメータ: 3000x3000 グリッド、障害物 900000 個（main.py の出力より）
- 環境（OS, Python, CPU）: Windows (MSVC), Python 3.12
- 備考: 総エントリ数 1,000,002、循環バッファが満杯で初期データが欠落

## ホットスポット（時間消費トップ）

| 順位 | 関数 / 位置                                                  | 総時間 (ms) | 総時間比 (%) | 備考                    |
| ---- | ------------------------------------------------------------ | ----------- | ------------ | ----------------------- |
| 1    | AStarPathfinder.find_path (a_star/pure_python.py:47)         | 86878.861   | 31.03        | 支配的な実行時間領域    |
| 2    | AStarPathfinder.get_neighbors (a_star/pure_python.py:33)     | 193.699     | 0.07         | 高い呼び出し回数 (75k+) |
| 3    | _heapq.heappop                                               | 189.035     | 0.07         | 優先度キューポップ      |
| 4    | _heapq.heappush                                              | 17.622      | 0.01         | 優先度キュープッシュ    |
| 5    | AStarPathfinder._reconstruct_path (a_star/pure_python.py:82) | 128.295     | 0.05         | 経路復元                |

## Rust 化候補

| 候補                              | 根拠                                                | 期待効果 | リスク / 備考                              |
| --------------------------------- | --------------------------------------------------- | -------- | ------------------------------------------ |
| find_path コアループ              | 実行時間の大半を占有。Python ループのオーバーヘッド | 高       | 現行 Python の挙動と同等性を要確認         |
| 優先度キュー操作 (heapq pop/push) | ループ内で高頻度に実行                              | 中       | Rust BinaryHeap 連携のバインディングが必要 |
| 近傍展開                          | 高い呼び出し回数。Python オーバーヘッド削減余地     | 中       | 近傍ロジックの正しさを検証                 |

## エッジケースと再実行ガイダンス

- スケーリング確認のための大小入力: 1000x1000 と 5000x5000 グリッドで再実行し増加傾向を比較
- トレースサイズ制御（最小時間 / エントリ数）: `--tracer_entries 2000000` または `--min_duration` でノイズ削減
- 既知の変動要因: 乱数 / 障害物配置によって探索ノード数が変動

## 意思決定ガイダンス

- ホットスポット -> 候補対応: find_path -> Rust コアループ、heapq -> Rust BinaryHeap、get_neighbors -> Rust 近傍展開
- 次のステップ案: 上位 2 件を Rust で実装し、改善を確認するため再プロファイル

## 成功基準とカバレッジ

- [x] 代表的な実行でトレース取得
- [x] 上位ホットスポットの時間と割合を記録
- [x] Rust 化候補を根拠付きで記載
- [x] 再実行ガイダンスを記載
- [x] 意思決定ガイダンスを完了
- カバレッジ概要: main.py の代表的な 1 回の実行。トレースバッファが溢れているため、完全なカバレッジには再実行を推奨
